<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 9.0.0rc2" />
<title>Latency Testing</title>
<link rel="stylesheet" href="..//asciidoc.css" type="text/css" />


<link rel="stylesheet" href="..//linuxcnc.css" type="text/css" />
<script type="text/javascript" src="..//asciidoc.js"></script>
<script type="text/javascript">
/*<![CDATA[*/
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Latency Testing</h1>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="sec:what-is-latency">1. What is latency?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Latency is how long it takes the PC to stop what it is doing and respond
to an external request, such as running one of LinuxCNC&#8217;s periodic
realtime threads.  The lower the latency, the faster you can run the
realtime threads, and the smoother motion will be (and potentially faster,
in the case of software stepping).</p></div>
<div class="paragraph"><p>Latency is far more important than CPU speed.
A lowly Pentium II that responds to interrupts within 10 microseconds
each and every time can give better results
than the latest and fastest P4 Hyperthreading beast.</p></div>
<div class="paragraph"><p>The CPU isn&#8217;t the only factor in determining latency.
Motherboards, video cards, USB ports, and
a number of other things can hurt the latency.
The best way to find out what you are dealing with is
to run the latency test.</p></div>
<div class="paragraph"><p>Generating step pulses in software
has one very big advantage - it&#8217;s free.
Just about every PC has a parallel port that is
capable of outputting step pulses that are generated by the software.
However, software step pulses
also have some disadvantages:</p></div>
<div class="ulist"><ul>
<li>
<p>
limited maximum step rate
</p>
</li>
<li>
<p>
jitter in the generated pulses
</p>
</li>
<li>
<p>
loads the CPU
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="sec:latency-tests">2. Latency Tests</h2>
<div class="sectionbody">
<div class="paragraph"><p>LinuxCNC includes several latency tests.  They all produce equivalent
information.  Running these tests will help determine if a computers is
suitable for driving a CNC machine.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Do not run LinuxCNC or Stepconf while the latency test is running.</td>
</tr></table>
</div>
<div class="sect2">
<h3 id="sec:latency-test">2.1. Latency Test</h3>
<div class="paragraph"><p>To run the test, open a terminal window
(in Ubuntu, from Applications → Accessories → Terminal)
and run the following command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>latency-test</code></pre>
</div></div>
<div class="paragraph"><p>This will start the latency test with a base-thread period of 25uS and a
servo-thread period of 1mS. The period times may be specified on the command
line:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>latency-test 50000 1000000</code></pre>
</div></div>
<div class="paragraph"><p>This will start the latency test with a base-thread period of 50uS and a
servo-thread period of 1mS.</p></div>
<div class="paragraph"><p>For available options, on the command line enter:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>latency-test -h</code></pre>
</div></div>
<div class="paragraph"><p>After starting a latency test you should see something like this:</p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<figure>
<img src="../config/images/latency-test_en.png" alt="HAL Latency Test"/>
<figcaption class="title"> Figure 1. HAL Latency Test</figcaption>
</figure>
</div>
</div>
<div class="paragraph"><p>While the test is running, you should <em>abuse</em> the computer.
Move windows around on the screen. Surf the web. Copy some large files
around on the disk. Play some music.
Run an OpenGL program such as glxgears.
The idea is to put the PC through its paces while
the latency test checks to see what the worst case numbers are.</p></div>
<div class="paragraph"><p>The important number for software stepping is the <em>max jitter</em> of the base thread.
In the example above, that is 6693 nanoseconds, or 6.693 microseconds.
Record this number, and enter it in Stepconf when it is requested.</p></div>
<div class="paragraph"><p>In the example above, latency-test only ran for a few seconds.
You should run the test for at least several minutes; sometimes
the worst case latency doesn&#8217;t happen very often, or only happens
when you do some particular action. For instance, one Intel
motherboard worked pretty well most of the time, but every 64
seconds it had a very bad 300 us latency. Fortunately that was
fixable, see <a href="https://wiki.linuxcnc.org/cgi-bin/wiki.pl?FixingSMIIssues">https://wiki.linuxcnc.org/cgi-bin/wiki.pl?FixingSMIIssues</a></p></div>
<div class="paragraph"><p>So, what do the results mean? If your Max Jitter number is less
than about 15-20 microseconds (15000-20000 nanoseconds), the
computer should give very nice results with software stepping. If
the max latency is more like 30-50 microseconds, you can still
get good results, but your maximum step rate might be a little
disappointing, especially if you use microstepping or have very
fine pitch leadscrews. If the numbers are 100 us or more (100,000
nanoseconds), then the PC is not a good candidate for software
stepping. Numbers over 1 millisecond (1,000,000 nanoseconds) mean
the PC is not a good candidate for LinuxCNC, regardless of whether you
use software stepping or not.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">If you get high numbers, there may be ways to improve
them. Another PC had very bad latency (several milliseconds) when
using the onboard video. But a $5 used video card solved the
problem.
LinuxCNC does not require bleeding edge hardware.</td>
</tr></table>
</div>
<div class="paragraph"><p>For more information on stepper tuning see the
<a href="../motion/tweaking-steppers.html#cha:stepper-tuning">Stepper Tuning</a> Chapter.</p></div>
<div class="paragraph"><p><strong>Additional command line tools are available for examining latency
when LinuxCNC is not running.</strong></p></div>
</div>
<div class="sect2">
<h3 id="_latency_plot">2.2. Latency Plot</h3>
<div class="paragraph"><p>latency-plot makes a strip chart recording for a base and a servo thread.
It may be useful to see spikes in latency when other
applications are started or used. Usage:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>latency-plot --help

Usage:
      latency-plot --help | -?
      latency-plot --hal [Options]

Options:
      --base nS  (base  thread interval, default:   25000)
      --servo nS (servo thread interval, default: 1000000)
      --time mS  (report interval, default: 1000)
      --relative (relative clock time (default))
      --actual   (actual clock time)</code></pre>
</div></div>
<div class="imageblock">
<div class="content">
<figure>
<img src="../config/images/latency-plot.png" alt="latency-plot Window"/>
<figcaption class="title"> Figure 2. <code>latency-plot</code> Window</figcaption>
</figure>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_latency_histogram">2.3. Latency Histogram</h3>
<div class="paragraph"><p>latency-histogram displays a histogram of latency (jitter) for
a base and servo thread.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Usage:
   latency-histogram --help | -?
   latency-histogram [Options]

Options:
  --base      nS   (base  thread interval, default:   25000, min:  5000)
  --servo     nS   (servo thread interval, default: 1000000, min: 25000)
  --bbinsize  nS   (base  bin size,  default: 100
  --sbinsize  nS   (servo bin size, default: 100
  --bbins     n    (base  bins, default: 200
  --sbins     n    (servo bins, default: 200
  --logscale  0|1  (y axis log scale, default: 1)
  --text      note (additional note, default: "" )
  --show           (show count of undisplayed bins)
  --nobase         (servo thread only)
  --verbose        (progress and debug)
  --nox            (no gui, display elapsed,min,max,sdev for each thread)

Notes:
  Linuxcnc and Hal should not be running, stop with halrun -U.
  Large number of bins and/or small binsizes will slow updates.
  For single thread, specify --nobase (and options for servo thread).
  Measured latencies outside of the +/- bin range are reported
  with special end bars.  Use --show to show count for
  the off-chart [pos|neg] bin</code></pre>
</div></div>
<div class="imageblock">
<div class="content">
<figure>
<img src="../config/images/latency-histogram.png" alt="latency-histogram Window"/>
<figcaption class="title"> Figure 3. <code>latency-histogram</code> Window</figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_latency_tuning">3. Latency tuning</h2>
<div class="sectionbody">
<div class="paragraph"><p>LinuxCNC can run on many different hardware platforms and with many
different realtime kernels, and they all may benefit from tuning for
optimal latency.</p></div>
<div class="paragraph"><p>A primary goal in tuning the system for LinuxCNC is to reserve a CPU for the exclusive use of LinuxCNC&#8217;s realtime tasks, so that other tasks (both user programs and kernel threads) do not interfere with LinuxCNC&#8217;s access to that CPU.</p></div>
<div class="paragraph"><p>When specific tuning options are believed to be universally helpful
LinuxCNC does this tuning automatically at startup, but many tuning
options are machine-specific and cannot be done automatically.  The person
installing LinuxCNC will need to experimentally determine the optimal
tuning for their system.</p></div>
<div class="sect2">
<h3 id="_tuning_the_bios_for_latency">3.1. Tuning the BIOS for latency</h3>
<div class="paragraph"><p>PC BIOSes vary wildly in their latency behavior.</p></div>
<div class="paragraph"><p>Tuning the BIOS is tedious because you have to reboot the computer,
make one small tweak in the BIOS, boot Linux, and run the latency test
(potentially for a long time) to see what effects your BIOS change had.
Then repeat for all the other BIOS settings you want to try.</p></div>
<div class="paragraph"><p>Because BIOSes are all different and non-standard, providing a detailed
BIOS tuning guide is not practical.  In general, some things to try
tuning in the BIOS are:</p></div>
<div class="ulist"><ul>
<li>
<p>
Disable ACPI, APM, and any other power-saving features.  This includes
  anything related to power saving, suspending, CPU sleep states, CPU
  frequency scaling, etc.
</p>
</li>
<li>
<p>
Disable CPU "turbo" mode.
</p>
</li>
<li>
<p>
Disable CPU hyperthreading.
</p>
</li>
<li>
<p>
Disable (or otherwise control) System Management Interrupt (SMI).
</p>
</li>
<li>
<p>
Disable any hardware you do not intend to use.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_tuning_preempt_rt_for_latency">3.2. Tuning Preempt-RT for latency</h3>
<div class="paragraph"><p>The Preempt-RT kernel may benefit from tuning in order to provide the
best latency for LinuxCNC.  Tuning may be done via the kernel command
line, sysctl, and via files in <code>/proc</code> and <code>/sys</code>.</p></div>
<div class="paragraph"><p>Some tuning parameters to look into:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Kernel command line
</dt>
<dd>
<p>
    Details here: <a href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt">https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt</a>
</p>
<div class="ulist"><ul>
<li>
<p>
<code>isolcpus</code>: Prevent most non-LinuxCNC processes from using these
      CPUs, leaving more CPU time available for LinuxCNC.
</p>
</li>
<li>
<p>
<code>irqaffinity</code>: Select which CPUs service interrupts, so that the
      CPUs reserved for LinuxCNC realtime don&#8217;t have to perform this task.
</p>
</li>
<li>
<p>
<code>rcu_nocbs</code>: Prevent RCU callbacks from running on these CPUs.
</p>
</li>
<li>
<p>
<code>rcu_nocb_poll</code>: Poll for RCU callbacks instead of using sleep/wake.
</p>
</li>
<li>
<p>
<code>nohz_full</code>: Disable clock tick on these CPUs.
</p>
</li>
</ul></div>
</dd>
<dt class="hdlist1">
Sysctl
</dt>
<dd>
<p>
    Details here: <a href="https://www.kernel.org/doc/html/latest/scheduler/sched-rt-group.html">https://www.kernel.org/doc/html/latest/scheduler/sched-rt-group.html</a>
</p>
<div class="ulist"><ul>
<li>
<p>
<code>sysctl.kernel.sched_rt_runtime_us</code>: Set to -1 to remove the limit
      on how much time realtime tasks may use.
</p>
</li>
</ul></div>
</dd>
</dl></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2023-06-17 21:52:11 CEST
</div>
</div>
</body>
</html>
